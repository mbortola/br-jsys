\documentclass[11pt,titlepage,a4paper,twoside,openany]{book}

\usepackage[italian]{babel}
%inputenc per win,Latin 1 o 9 per linux
\usepackage[ansinew]{inputenc}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{footmisc}
\usepackage{listings}
\usepackage{inputenc}
\usepackage{lastpage}
\usepackage{color}

\pagestyle{fancy}

\begin{document}  % required; doc starts here
\begin{titlepage}
\begin{center}
\textbf{
\Huge Universita degli studi di Padova\\
\Large Facolta' di scienze MM. FF. NN.\\ 
Laurea triennale in informatica.\\
 Anno Accademico 2007-2008. \\
\Large Tesi di Laurea:\\ 
Utilizzo di XML per la gestione di file di configurazione in ambito aziendale.}
\end{center}

\end{titlepage}
\tableofcontents
\chapter{Sommario}
Lo scopo dello stage e' quello di utilizzare XML per rappresentare i file di configurazione utilizzati nel Software Portal Zoom.
Questi file attualmente vengono rappresentati tramite file di testo difficili da interpretare e sopratutto poco manipolabili, dato che la loro lettura e la loro modifica deve per forza avvenire in maniera sequenziale.
Convertendo questi file in formato XML si avra il vantaggio di poterli gestire molto piu facilmente.
Durante lo sviluppo di Portal Zoom questi file di configurazione hanno subito varie modifiche alla struttura e ai contenuti, tramite trasformate XSL e' possibilie aggiornare file di vecchia versione in maniera molto piu efficiente.
Successivamente associeremo a questi file un XML Schema per descriverne la struttura e per validare l'output prodotto, probabilmente affiancheremo alla validazione tramite Schema alcune semplici interrogazioni XPath.

\chapter{Lo stage}

\section{Cos' \`e Sitepainter}
i-CASE(Internet Computer Aided Software Engineering) Software prodotta dalla Zucchetti che consente lo sviluppo di applicazioni business transazionali in ambiente web, fortemente interattive, con interfaccia browser.

\section{Strumenti di lavoro}

\subsection{Terminale utilizzato}
L'attivita\` di stage e\`stata svolta lavorando su un pc dalle seguenti caratteristiche:
\begin{itemize}
 \item Processore Intel Pentium 4, 2800 MHz
 \item 1024 MB Memoria RAM
 \item 16 KB Cache L1
 \item 1024 KB Cache L2
 \item Sistema operativo Microsoft Windows XP
\end{itemize}


\subsection{Linguaggi utilizzati}
\subsubsection{Java}Le applicazioni sono state sviluppate in Java dato che SitePainter e\` scritto in questo linguaggio.
\subsubsection{XML}XML e\` stato utilizzato per la maggior parte dello stage, in prevalenza per gestire i file di configurazione.
\subsubsection{XQuery} XQuery e\` stato utilizzato soltanto per alcuni confronti con XSLT e in accoppiata con eXist per evidenziare le potenzialita\` di quest' ultimo.
\subsubsection{Latex}Usato per la stesura della tesi.
\subsubsection{Altri linguaggi usati}
\`E stato utilizzato inoltre il linguaggio tipico di ANTLR per la definizione della grammatica per descrivere la struttura dei file di configurazione, di conseguenza \`e stato utilizzato il linguaggio generato da ANTLR.
\subsection{Applicativi utilizzati}

\subsubsection{oXygen}
Potente applicativo per la gestione di documenti XML, permette tra le varie cose una rapida gestione di file XML, un ottimo interfacciamento coi processori XSLT e XQuery e una rapida gestione degli XML-Schema e dei DTD.

\subsubsection{Eclipse}
Eclipse e' un software open source per la realizzazione di applicazioni java, consente un rapido contollo degli errori tramite una continua compilazione del codice prodotto, nonche consente la correzzione automatica, che evita di dover ogni volta scrivere per esempio i vari blocchi try-catch. Possiede un potente debugger, automatizza la generazione di javadoc, ed ha la possibilita' di installare numerosi plugins per fare svariate cose(diagrammi uml, sviluppare in C, editor latex, debugging di grammatiche antlr...).

\subsubsection{eXist}

\subsubsection{ANTLRWorks}Tool per la generazione user-friendly di grammatiche con ANTLR.

\subsubsection{Poseidon UML} Usato per la stesura di diagrammi UML.

\subsubsection{Led}Editor per Latex

\section{Standard adottati}

\subsection{Standard del disegno architetturale}
\subsection{Standard della documentazione del codice}

%Da mettere nel glossario
\section{XML}
XML (eXtensible Markup Language) e' un metalinguaggio creato e gestito dalla w3c per la rappresentazione di informazione. e' derivato da una semplificazione di SGML.
\section{XML Schema}
Strunmento per la validazione di un documento XML, alternativa al DTD.
\section{XSLT}
XSLT (eXstensible Stylesheet Language Transformations) e' il linguaggio per la descrizione dei fogli di stile in XML, un documento XSL associato ad un documento XML puo produrre in output qualsiasi tipo di file testuale (HTML, XML, solo testo...).
\section{DOM}
DOM (Document Object Model) e\` una forma di rappresentazione dei documenti strutturati come modello orientato agli oggetti. Fa parte dello standar w3c per accedere a documenti XML e HTML.In DOM tutto e' trattato come un nodo, in particolare:
\begin{itemize}
\item L'intero documento e' un nodo \textit{Document};
\item Un elemento e' un nodo \textit{Element};
\item Il testo nel elemento XML e' un nodo \textit{Text};
\item Un attributo di un elemento XML e' un nodo \textit{Attribute};
\item Un commento e' un nodo \textit{Comment}.
\end{itemize}
Tramite vista ricorsiva riusciamo a creare e a leggere file XML, DOM viene supportato da diversi linguaggi di programmazione come JAVA, C++, Lisp, PHP, Python, Ruby ecc..

\section{SAX}

SAX offre un modo diverso rispetto al DOM di leggere un documento XML, permette soltanto di leggere XML ma non di creare o modificare.
La lettura di un documento XML da parte di SAX avviene in modo sequenziale, legge carattere per carattere come fosse un semplice file testuale, alla fase di lettura, o meglio di parsing, viene associato un parser che puo' sollevare eventi ogniqualvolta trova :
\begin{itemize}
\item Un tag d'apertura o chiusura;
\item Un tag di inizio o fine documento;
\item Una Processing Instruction;
\item Un errore.
\end{itemize}
Uno dei vantaggi che possiede SAX e' quello di non necessitare di tenere in memoria tutto il documento XML, dunque sarebbe preferibile utilizzarlo per la lettura di grossi file.


\section{JSON}
Acronimo di JavaScript Object Notation, e\` un formato adatto per lo scambio dei dati in applicazioni client-server.
Spesso viene usato in AJAX come alternatica a XML.
E' un formato molto semplice da imparare e da utilizzare, e' supportato praticamente da tutti i linguaggi ciononostante e' indipendente da essi e dalla piattaforma utilizzata.
Supporta i tipi di dato basilari (integer, double, char, string, array, null) e consente l'annidamento di JSON tra di loro, consentando la rappresentazione anche di strutture dati complesse.
La struttura base di un oggetto JSON e' composta da una sequenza non ordinata di coppie nome-valore, nal caso di rappresentazione di un array invece abbiamo soltanto una sequenza ordinata di soli valori.
\\
Per esempio il seguente elemento scritto in XML:

\lstset{language=HTML}
\begin{lstlisting}

<element>
	<a>Testo</a>
	<b>123</b>
	<array>
		<e>primo</e>
		<e>secondo</e>
		<e>terzo</e>
		<e>quarto</e>
	</array>
</element>

\end{lstlisting}

Puo\` trovare una analoga rappresentazione come elemento JSON:

\begin{lstlisting}
{a:'Testo', b:123, array:['primo', 'secondo', 'terzo', 'quarto' ]}
\end{lstlisting}

\section{Xalan}
Xalan e' uno strumento che consente di effettuare trasformate XSL in ambiente JAVA appoggiandosi a SAX e a DOM, e' un servizio fornito da Apache.

\section{ANTLR}
ANTLR (ANother Tool for Language Recognition) e' un generatore di parser che consente, una volta generato un file che descrive la grammatica, un parser e un lexer. Fornisce parser in linguaggio Java, C++, Python ma il programma evolvendosi continuamente, non esculde in futuro il supporto per molti altri linguaggi.
Cio che rende ANTLR un ottimo strumento per la creazione di linguaggi e' anche la possibilita' di utilizzare un tool grafico (AntlrWorks) che consente una visione immediata di cio che si sta effettuando, nonche consente un rapido ed efficace debugging.

\chapter{Descrizione dell'attivita' di stage}
L'attivita' di stage consiste nello studio di varie metodologie basate su XML per la trattazione di file di configurazione, in particolare si faranno alcuni esperimenti per vedere come con XML si possono aumentare le prestazioni nella trattazione di dati.
\begin{itemize}
	\item Si costruiranno delle applicazioni per la conversione in XML di oggetti JSON e viceversa.
	\item Si valuteranno i tempi di esecuzione di alcune elaborazioni XSLT con l'obbiettivo di rappresentare come struttura nidificata un XML piatto.
	\item Si valuteranno i servizi offerti da un DBMS XML (eXist) valutando se puo\` convenire sfruttarlo per l'immagazzinamento dei dati.
	\item Si costruira\` un applicazione per la conversione di file di configurazione rappresentati tramite oggetti DOM, aggiungendo dove opportuno elementi precedentemente non presenti, le specifiche sulla struttura di un file di configurazione verranno rappresentata tramite la creazione di un linguaggio ad-hoc con relativo parser per la generazione di un albero necessario per un confronto parallelo. Per la generazione del parse ci si appoggiera' ad un generatore di parser(ANTLR)
\end{itemize}

L'obiettivo finale dello stage sara dunque quello di vedere come il trattamento dei dati con XML puï¿½ in certi casi facilitare l'esecuzione di alcune applicazioni.



\chapter{Lavorare con XSLT}
Realizzare XSL e' un operazione che puo' far storcere il naso ad alcuni programmatori.
La verbosita' tipica di XML nonche' il rigore nella definizione dei vari elementi puo' rendere di difficile comprensione il foglio di stile prodotto.
E' consigliabile appoggiarsi fortemente alla risorsione e basato su query XPath opportune per la selezione degli elementi da elaborare.

Questo non vuole essere un tutorial su come funziona XSLT o una carrellata sui metodi che offre ma vuole semplicemente elencare cosa rende XSLT un interessante od ostile che dir si voglia.

\section{Punti di forza di XSLT}
Adottando una opportuna metodologia di programmazione, si riescono ad avere prestazioni di elaborazione eccezzionali. E' dunque necessario prender confidenza con gli strumenti offerti.
Ovviamente e' necessario avere dimestichezza con XPath, sopratutto bisogna aver fatto abbastanza pratica da capire il modo migliore per muoversi nel documento XML con esso.

\subsection{L'elemento xsl:apply-templates}
In XSLT esiste il concetto di template, esso prende in ingresso un nodo (sia esso elemento, attributo o testo) e lo elabora, la trasformazione essenzialmente e' composta di varie elaborazioni di template.

Solitamente la trasformazione inizia con l'elaborazione del template associato al nodo radice e da esso, in base all'occorrenza, vengono richiamati altri template. Un template puo' essere chiamato per nome tramite l'elemento xsl:call-template al quale va aggiunto il nome del template da chiamare. In alternativa si usa apply-templates con l'attributo select che specifica quali nodi sono coinvolti nella chiamata ricorsiva, cio rentd la trasformazione molto rapida in quanto permette una gestione parallela delle varie chiamate, personalemtne ho notato che la struttura del foglio stile usando questo elemento risulta molto piï¿½ comprensibile e il testo piu leggibile, ovviamente bisogna fare un po di pratica.

\subsection{L'elemento xsl:key}
xsl:key permette di raggruppare un insieme di nodi definiti dall'utente in base a qualche espressione solitamente ricavabile dall'elaborazione ddel valore del nodo stesso o di sotto nodo nel caso di elementi. In definitiva funziona come un metodo Hash che dato in ingresso valore mi ritorna tutti i nodi ai quali xsl:key e' associata.
La sintassi di xsl:key e' la seguente:
<xsl:key name='nome' match='nodo match' use='pattern'/>
\begin{itemize}
\item L'attributo name da un nome alla chiave, necassario dato che in un foglio stile possono esserci piu' chiavi.
\item L'attributo match specifica il pattern che identifica un nodo contenente la chiave.
\item L'attributo use specifica quale espressione utilizzare per raggruppare i nodi, solitamente e' un valore di un elemento o di un attributo ma nulla vieta di farlo corrispondere alla concatenazione di piu valori o altro.
\end{itemize}

Per utilizzarla ci si serve della funzione key('nome chiave', parametro) che ritornerï¿½ tutti i nodi che hanno il valore corrispondente al parametro, ovviamente 'nome chiave' serve in quanto, come detto prima, posso definire piï¿½ chiavi nello stesso foglio stile.
xsl:key e' un elemento che va inserito solo come figlio diretto dell'elemento xsl:stylesheet, ossia dell'elemento radice di ogni foglio stile.

\section{Il raggruppamento in XSLT}
Uno dei punti ostici che si possono incontrare nella realizzazione di fogli stile \`e quello relativo al raggruppamento, se io ho un insieme di nodi che voglio gestire raggrupandoli per valore ho bisogno innanzi tutto di procurarmi tutti i valori distinti dei valori che uso per il raggruppamento e solo dopo cio' faro una serie di espressioni selettive per recuperarmi tutti i valori che mi servono, ricordo che la funzione distinct-values('set di nodi') che ritorna una lista di valori distinti dato l'input \`e disponibile solo da XSLT 2.0 dunque per raggruppare devo fare molta pi\`u fatica di quanto non si possa pensare.
C'e' da dire inoltre che avendo a che fare con basi di dati molto grandi l'utilizzo di metodologie sbagliate porta inevitabilmente a drastici rallentamenti nell'elaborazione.

Un primo approccio al problema del raggruppamento puo' essere il quello di considerare i nodi che hanno il valore di raggruppamenmto diverso da tutti i suoi fratelli a destra(o a sinistra), implementando ciï¿½ in una for-each avrei una espressione del genere:

<xsl:for-each select='elemento[not(grouping = preceding-sibling::elemento/grouping)]'>
...
</xsl:for-each>

In questo caso il for-each fara' tante iterazioni quanti sono i valori distinti del valore grouping ma si puo facilmente vedere che il il tempo speso per analizzare tutti i fratelli a destra cresce in maniera esponenziale, nonche' salta subito all'occhio che facendo cosi si ripete la stessa operazione numerose volte.

\subsection{Muenchian Method}
Attualmente il metodo migliore per effettuare il raggrupamento in XSLT 1.0 prende il nome di metodo Muenchian, dal nome del creatore (Steve Muench) ed utilizza xsl:key accoppiata alla funzione XPath generate-id() la quale identifica in modo univoco il nodo dato come parametro di ingresso.
Innanzi tutto creo un elemento chiave che identifica l'insieme dei nodi di ritorno in base al nodo o alla combinazione di essi per i quali voglio effettuare il raggruppamento, l'elemento for usato come esempio sopra puï¿½ dunque essere riscrittob in questo modo:

<xsl:for-each select='elemento[generate-id(.)=generate-id(key('nome chiave',grouping)[1])]'>
...
</xsl:for-each>

L'espressione condizionale sarï¿½ vera solo per quegli elementi con id uguale al id del primo elemento del insieme ritornato dalla funzione key.
Raggruppare col metodo Muenchian puo incrementare di molto le prestazioni di elaborazione, in particolare mentre il metodo tradizionale operava con complessitï¿½ esponenziale col metodo muench si opera con complessitï¿½ quasi lineare.

Nel caso in cui volessi effettuare il raggruppamento basandomi su piï¿½ nodi non devo fare altro che sviluppare una xsl:key che indicizza in base alla concatenazione dei vari nodi di ragguppamento e comportarmi in maniera opportuna nell'espressione condizionale del metodo Muench.


\section{XSLT 2.0}
XSLT 2.0 sta pian piano sostituendo XSLT 1, ad essa vengono aggiunte alcune funzionalita con lo scopo di facilitare la stesura di fogli stile, eaumantare la potenza computazionale.
\subsection{xsl:for-each-group}
E' stato aggiunto l'elemento xsl:for-each-group che estende il for-each consentendo il ragguppamento, possiede infatti l'attributo group-by (o anche delle varianti) per definire le opzioni di raggruppamento.
\subsection{Funzioni definite dall'utente}
Sebbene l'elemento xsl:template assomigli nel funzionamento ad un funzione, essa non consente di ritornare valori, cosa alquanto scomda sopratutto pwer chi e' abituato a lavorare coi comuni linguaggi di programmazione, l'elemento xsl:function permentte adesso di ritornare un valore in uscita, sia esso un valore atomico on un nodo(anche complesso).
\subsection{Altre funzionalitï¿½ nuove in XSLT 2.0}
Oltre a quanto detto sopra ï¿½ necessario sottolineare che la nuova versione di XSLT permette la generazione di output multipli, inoltre consente lo strong typing permettendo una gestione avanzata dei documenti XML evitando errori nella programmazione. Per una descrizione completa delle funzionalitï¿½ di XSLT 2.0 si rimanda a [link!!!!!!!!!!]

\chapter{Lavorare con XQuery}
Allo stato attuale con XQuery si possono fare le stesse cose cha si fanno con XSLT, chi sceglie di utilizzare il primo lo fa probabilmente perchï¿½ ï¿½ scritto in un linguaggio piï¿½ vicino ai comuni linguaggi di programmazione, il fatto che non sia XML perï¿½ non consente di trattarlo come tale (validazione, parsing con DOM o SAX ecc...) c'e' inoltre da ricordare che le tecniche di elaborazione dei due linguaggi sono per certi aspetti differenti, basti pensare che XQuery manca di un analogo alla xsl:key.
Difatti si ï¿½ notato che effettuare un raggruppamento su un file di medie dimensioni comporta tempi di elaborazione piu' lunghi che non farlo con XSLT, anche se la stesura del programma con XQuery risulta molto piï¿½ semplice.


\chapter{Exist}
Exist ï¿½ un DBMS open source interamente basato su XML, su occupa dunque di gestire grosse moli di documenti XML (ma al suo interno puï¿½ contenere qualsiasi tipo di file) per ottimizzare le interrogazioni, gestire i permessi di accesso e automatizzare molte delle operazioni effettuabili su file XML.
Per esempio lo sviluppo di un sito WEB basato su una base di dati in XML potrebbe venir gestito da eXist immagazzinando in esso la base dati (solitamente composta da piï¿½ file), le varie immagini e applet, nonche i fogli di stile necessari per sviluppare la pagina HTML.
Exist ï¿½ sviluppato interamente in JAVA, risulta dunque abbastanza semplice la creazione di applicazioni JAVA che si interfacciano con esso.

\section{Gestire le risorse con eXist}
La maggior parte delle operazioni per la gestione dei file puï¿½ essere fatta direttamente tramite XQuery, eXist infatti fornisce alcune funzioni per rendere immediate operazioni che altrimenti richiederebbero una apposita sequenza di chiamante a metodi JAVA.
La funzione store per esempio permette di creare una nuova risorsae e posizionarla dove si vuole col contenuto che si vuole. si possono inoltre gestire le collezioni di risorse creando una struttura ramificata, inserendo , modificando ed eliminando a piacimento.
Inoltre ï¿½ possibile applicare una trasformata XSLT da XQuery tramite la funzione trasform().
Altri metodi per una gestione specifica del testo, per le funzioni matematiche o per altro vengono definiti nel package util

\section{Altre funzionalitï¿½ di eXist}
\subsection{XUpdate}
Tramite XUpdate e' possibile modificare un file XML inserendo, cancellando, sostituendo o rinominando nodi, La gestiobe dei comandi XUpdate puo\` avvenire anch'essa tramite XQuery.
\subsection{Personalizzare Trigger}
E' possibile definire dei trigger personalizzati in grado di essere lanciati in automatico secondo direttive espresse dall'utente, possono essere creati o gestiti tramite linguaggio java oppure tramite apposite query.
\subsection{Personalizzare gli indici}
Per ottimizzare ulteriormente il movimento all'interno di un documento XML e' possibile definire degli indici personalizzati. Essi sono tutt'ora in fase di sviluppo e nei rilasci successivi probabilmente verrano aggiunte funzionalita\`, sono scritti in XML e gestibili tramite Java o XQuery.

\chapter{Lavorare con ANTLR}

\chapter{Definizione del linguaggio per la descrizione dei file di configurazione}
Come detto precedentemente serve la definizione di un linguaggio per descrivere i file di configurazione, un istanza di un file di configurazione risulta di immediata comprensione se rappresentata tramite un oggetto JSON o un elemento XML, ma per una descrizione della sua struttura queste rappresentazioni non servono.
Inizialmente si era pensato di utilizzare per la rappresentazione un XML Schema, dato che abbiamo comunque a che faer con XML, ma quest'ultimo risulta troppo complesso per i noastri scopi, nonche' si sarebbe dovuto obbligare chiunque avesse a che fare coi file di configurazione ad imparare la sintassi XML-Schema.
Dopodiche\` si era pensato di ripiegare nei DTD, piu\` semplici e facili da capire. Ma il fatto che il DTD sia stato fatto per descrivere XML grava non di poco sul suo utilizzo in ambiti non XML.
In definitiva dobbiamo tener conto non solo di dover trovare un formalismo per descrivere i file di configurazione, ma dobbiamo anche dalla descrizione del file ricavare una sorta di struttura dati per fare l'analisi dell'oggetto istanza del file stesso(ghghghg!!!!!).
Si e' infine deciso di creare un linguaggio ad-hoc, completo di parser e di generatore di albero sintattico da appoggiare all'applicazione di controllo per fare confronto parallelo con l'istanza, rappresentate per l'occasione da un elemento DOM, l'applicazione al termine della lettura restituira' lo stesso DML corretto dove serve aggiungendogli opportuni elementi di default.
Ovviamente la realizzazione di un parser sarebbe un operazione estremamente onerosa nel caso in cui non si utilizzasse uno strumento che automatizzasse la stesura del codice, per questo ci siamo affidati ad ANTLR, probabilmente senza uno strumento apposito avremmo impiegato quasi tutto il periodo di stage a realizzare il parser, tenuto conto anche del fatto che la grammatica ha subito varie modifiche nel corso della sua stesura.

\section{Struttura del linguaggio}
Per la definizione del linguaggio si sono stabiliti alcuni vincoli iniziali:
\begin{itemize}
\item Si deve permettere la definizione di tre tipi atomici ossia intero, booleano e stringa;
\item Si deve permettere la definizione di sotto oggetti;
\item Si deve permettere la definzione di array, nel nostro caso gli array conterranno elementi analoghi, dunque o tutti interi, booleani, stringa ,oggetti(dello stesso tipo), o sottoarray;
\item L'ordine dei campi dato di un oggetto e' irrilevante, mentre l'ordine degli elementi in un array e' fondamentale dato che l'unico modo per distinguerli e' la loro posizione.
\item Un campo dati puo essere opzionale o obbligatorio, nel secondo caso se si tratta di un elemento atomico e' possibile definire un valore di default da inserire nel caso manchi nel DOM in ingresso. 
\item La grammatica deve essere il piu\` semplice possibile e deve essere fatta in modo da rendere praticamente immadiata la stesura di un descrittore di file di configurazione.
\end{itemize}

Si e' successivamente notato che la definizione di sotto oggetti e sotto array rischiava di generare strutture ad albero eccessivamente innestate, molto spesso ripetute. Come soluzione a questo problema si e' deciso di fare in modo che la grammatica permettesse di definire dei riferimenti ed associarli ad un tipo definito separatamente.

Un esempio di descrittore di file di configurazione e' il seguente:
\lstset{language=make}
\begin{lstlisting}
VZM:(
	f:col+,
	z:int?,
	t:str*,
	m:(m1:int,m2:bool)?,
)

col:(
	k:int:=14,
	k1:bool:=true,
	k2:str:="null"
)
\end{lstlisting}

\begin{itemize}
\item VZM e'l'oggetto radice.
\item f e' un array di tipo col obbligatorio, in quanto ce ne deve essere almeno uno dato il simbolo +;
\item z e' di tipo intero opzionale;
\item t e' un array di stringhe opzionale come si vede dal simbolo *;
\item m e' un sotto oggetto definito inline composto da 2 elementi atomici m1 e m2;
\item col viene definito separatamente ed si nota essere un oggetto;
\item k e' un intero obbligatorio che possiede un valore di default nel caso non venga trovato durante la lettura, lo stesso vale per k1 e k2 rispettivamente elementi stringa e bool.
\item Un file di configurazione aderente a questo descrittore possiedera' dunque questa struttura, da notare che col non e' il nome di un campo dati come gli altri ma il nome di un riferimento, nel file di configurazione non esistera' dunque un campo dati chiamato col.
\end{itemize}

\section[Esempio]{Esempio di elaborazione file di configurazione}

Sia data la seguente struttura di file di configurazione:
\lstset{language=make}
\begin{lstlisting}
VZM:(
name:str,
version:=1,
records:record*,
)

record:(
val1:int:=4,
val2:str:="null",
val3:m?
)

m:(
id:int:=0,
value:str:"null")

\end{lstlisting}

E il seguente DOM da analizzare:
\lstset{language=HTML}
\begin{lstlisting}
<VZM>
   <name type="String" value="editor"/>
   <records elements="3" type="list">
      <Item position="0">
         <val1 type="Integer" value="3"/>
         <val2 type="String" value="Kg"/>
      </Item>
      <Item position="1">
         <val3 elements="2" type="list">
            <Item position="0">
               <id type="Integer" value="9"/>
            </Item>
            <Item position="1">
               <value type="String" value="valore"/>
            </Item>
         </val3>
         <val2 type="String" value="sec"/>
      </Item>
      <Item position="2">
         <val3 elements="2" type="list">
            <Item position="0">
               <id type="Integer" value="12"/>
               <value type="String" value="pz"/>
            </Item>
            <Item position="1">
               <id type="Integer" value="9"/>
            </Item>
         </val3>
      </Item>
   </records>
</VZM>
\end{lstlisting}

Come si puo\` notare il DOM da analizzare necessita di alcuni elementi aggiuntivi perche'corrisponda alla descrizione del file.
L'applicazione modifichera di conseguenza il DOM trasformandolo nel seguente:

\lstset{language=HTML}
\begin{lstlisting}
<VZM>
   <name type="String" value="editor"/>
   <records elements="3" type="list">
      <Item position="0">
         <val1 type="Integer" value="3"/>
         <val2 type="String" value="Kg"/>
      </Item>
      <Item position="1">
         <val3 elements="2" type="list">
            <Item position="0">
               <id type="Integer" value="9"/>
               <val1 type="Integer" value="4"/>
               <val2 type="String" value="null"/>
            </Item>
            <Item position="1">
               <value type="String" value="valore"/>
               <val1 type="Integer" value="4"/>
               <val2 type="String" value="null"/>
            </Item>
            <id type="Integer" value="0"/>
            <value type="String" value="null"/>
         </val3>
         <val2 type="String" value="sec"/>
         <val1 type="Integer" value="4"/>
      </Item>
      <Item position="2">
         <val3 elements="2" type="list">
            <Item position="0">
               <id type="Integer" value="12"/>
               <value type="String" value="pz"/>
               <val1 type="Integer" value="4"/>
               <val2 type="String" value="null"/>
            </Item>
            <Item position="1">
               <id type="Integer" value="9"/>
               <val1 type="Integer" value="4"/>
               <val2 type="String" value="null"/>
            </Item>
            <id type="Integer" value="0"/>
            <value type="String" value="null"/>
         </val3>
         <val1 type="Integer" value="4"/>
         <val2 type="String" value="null"/>
      </Item>
   </records>
   <version type="Integer" value="1"/>
</VZM>
\end{lstlisting}
\section{Funzionamento}
Il funzionamento dad alto livello dell'applicazione e' illustrato nel seguente diagramma di sequenza:
%Diagramma di sequenza
Il chiamante crea l'oggetto ConfigurationManager passandogli il file contenente la descrizione del file di configurazione, dunque il costruttore si occupa di effettuare il parsing della stringa passatagli.
Se il parsing e' andato a buon fine l'oggetto configurationManager conterra' un campo dati che rappresenta l'AST che descrive il stringa e\` parsata, nonche' una tabella Hash che associa ad ogni nome di elemento radice il suo rispettivo sotto-AST.
Qualora necessitassi di analizzare un DOM per aggiornarlo secondo le specifiche del descrittore mi appoggiero' al metodo reader che prende in ingresso l'elemento da elaborare in formato JSON, lo elabora e pone il risultato in un file specificato.
A dire il vero esistono vari metodi reader, ciascuno con lo stesso scopo ma che accettano vari tipi di input, un elemento da analizzare puo' trovarsi in un file, o essere semplicemente una stringa, inoltre e possibile passare direttamente un oggetto DOM senza dover passare attraverso JSON. 
Infine e' presente anche il metodo reader che accetta soltanto un nodo Document DOM che effettua la lettura e pone il risultato nel campo dati privato di ConfgurationManager doc, qualora dovessi reperire questo risultato utilizzero il metodo getDoc.

In ogni caso indipendentemente dal modo in cui viene rappresentato il file di configurazione in ingresso la sua fase di analisi viene sempre fatta accostando l'AST alla sua rappresentazione in un nodo Document DOM.

\subsection{Come viene effettuata la lettura del file di configurazione}
In effetti cio che viene letto durante la fase di controllo del file di configurazione e' l'AST, il DOM-file di configurazione viene affiancato parallelamente ad esso in cerca di analogie.
La fase di lettura vera e propria viene effettuata dal metodo ricorsivo \textit{read} che prende due parametri:
\begin{itemize}
\item \textit{tree:Tree} Ossia un nodo dell'AST del quale si analizzeranno i figli;
\item \textit{root:Element} Ossia un elemento DOM che teoricamente dovrebbe essere descritto da \textit{tree}.
\end{itemize}
Il seguente diagramma di attivita\` illustra la struttura del metodo \textit{read}:
%diagramma attivita read

Inizialmente mandero' al metodo read la radice dell'AST e l'elemento radice del DOM.
Dovro\` scandire tutti i figli diretti di tree, per ogni figlio ricavo informazioni sulle sue caratteristiche tramite metodi ad hoc, ossia guardo se e' un array, o se e' opzionale.
Il primo controllo che faccio e' quello per vedere se e' un array di elementi atomici (interi, stringa o bool), non sono tenuto a rimpiazzare l'eventuale mancanza di questo elemento, ne sono tenuto a lanciare una eccezzione, dunque lascio stare.

Se questo test fallisce controllo se mi trovo di fronte ad un array, in caso affermativo vado piu in dettaglio con l'analisi.
\subsubsection{Gestione Array}
Il seguente diagramma delle attivita' mostra la sotto attivita' siguardante le varie fasi di analisi di un array:
%Diagramma attivita per array
Abbiamo precedentemente ricavato i sotto elemento nel DOM riferito da child (se presente) e dobbiamo ora passatre attraverso vari rami condizionali per fare le operazioni opportune.
Inizialmente faccio il test per vedere se nel DOM manca un array obbligatorio, in questo caso ci troviamo di fronte ad un DOM non valido e fermiamo l'esecuzione del preogramma tramite il sollevamento di una eccezzione creata appositamente (MyError).
Altrimenti vedo se nel DOM e' presente l'occorrenza di child, se non e' presente allora l'array rappresentato da child e' opzionale e posso uscire dalla sotto attivita'.
Se invece nel DOM abbiamo una occorrenza ci troviamo di fronte ad un array (non vuoto) per il quale devo effettuare la chiamata ricorsive read per ogni elemento.
Resta da vedere se la definizione della struttura degli elementi dell'array e' descritta innestata su child o se deve essere ricavata dalla tabella hash.
Trovata la giusta posizione del sotto albero, lancio ricorsivamente read ai figli di primo grado di \textit{e}\footnote[1]{Per esaminare i sotto figli di un elemento uso il metodo di Element \textit{getElementsByTagName}. 
Purtroppo questo metodo ritorna un \textit{NodeList} contentente tutti i nodi figli dell'elemento oggetto di invocazione e non solo quelli al primo livello dunque nel caso di array innestati il programma non eseguirebbe correttamente.
Dunque prima di lanciare ricorsivamente la read su tutti gli elementi della lista devo prima vedere se sono figli diretti dell'oggetto di invocazione, per fare ciï¿½ controllo che l'elemento che voglio analizzare abbia come padre la redice \textit{e}.}.
\subsection{Gestione sotto oggetti o campi valore atomici}
Qualora non fosse un array allora e' un oggetto oppure un elemento atomico il diagramma di attivita seguente mostra nel dettaglio le varie fasi:
%Diagramma attivita' non-array
Il test iniziale controlla se child e' opzionale e se non e' presente nel DOM, in questo caso non devo ovviamente fare niente, in caso contrario vedo se child descrive un valore atomico o un sotto oggetto.
Nel caso child sia un elemento atomico e non sia presente nel DOM lo si inserirï¿½, prima pero si invocherï¿½ il metodo per cercare in child il valore di default (\textit{findDefault()})\footnote[2]{E' consentito secondo le specifiche del linguaggio per descrivere i file di configurazione assegnare un default ad un elemento, ma qualora non fosse specificato nessun valore di default si creera' un elemento con un valore prefissato: 0 nel caso di interi, \textit{true} nel caso di booleani e la stringa vuota nel caso di stringhe.}

\chapter{Conclusioni}
\chapter{Appendici}
\chapter{Glossario}
\chapter{Riferimenti}

\end{document}
